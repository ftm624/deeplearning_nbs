
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/09_datablock.ipynb

from exp.nb_08 import *

import PIL, os, mimetypes
from pathlib import Path

Path.ls = lambda x: list(x.iterdir())

image_extension = set(k for k,v in mimetypes.types_map.items() if v.startswith('image'))

def setify(x): return x if isinstance(x, set) else set(listify(x))

def _get_files(p, fs, extensions=None):
    p = Path(p)
    # path / filename  if it does not start with a '.' and (no extensions are given OR the suffix is in extensions)
    res = [p/f for f in fs if not f.startswith('.') and ((not extensions) or f'.{f.split(".")[-1].lower()}' in extensions)]
    return res


def get_files(path, extensions=None, recurse=False, include=None):
    path = Path(path)
    extensions = setify(extensions)
    extensions = {e.lower() for e in extensions}

    if recurse:
        res = []
        #dirpath, dirnames, filenames
        for i,(p,d,f) in enumerate(os.walk(path)):
            if include is not None and i==0:
                d[:] = [o for o in d if o in include]
            else:
                d[:] = [o for o in d if not o.startswith('.')]
            res += _get_files(p, f, extensions)
        return res

    else:
        f = [o.name for o in os.scandir(path) if o.is_file()]
        return _get_files(path, f, extensions=extensions)

def compose(x, funcs, *args, order_key="_order", **kwargs):
    key = lambda o: getattr(o, order_key, 0)
    for f in sorted(listify(funcs), key=key): x = f(x, **kwargs)
    return x


class ItemList(ListContainer):
    def __init__(self, items, path='.', tfms=None):
        super().__init__(items) #passes all items to the ListContainer
        self.path,self.tfms = Path(path),tfms

    def __repr__(self): # shows the first 10 items and then the path
        return f'{super().__repr__()}\nPath: {self.path}'

    def new(self, items, cls=None): # will be used when we need to split the data later
        if cls is None: cls=self.__class__
        return cls(items, self.path, tfms=self.tfms)

    def get(self, i):
        return i

    def _get(self, i): # processing by transforms is done on the fly - when __getitem__ is called
        return compose(self.get(i), self.tfms)

    def __getitem__(self, idx):
        res = super().__getitem__(idx)
        if isinstance(res,list): return [self._get(o) for o in res]
        return self._get(res)

class ImageList(ItemList):
    @classmethod
    def from_files(cls, path, extensions=None, recurse=True, include=None, **kwargs):
        if extensions is None: extensions = image_extension
        return cls(get_files(path, extensions, recurse=recurse, include=None), path, **kwargs)

    def get(self, fn): return PIL.Image.open(fn)


class Transform():
    _order = 0

class MakeRGB(Transform):
    def __call__(self, x): return x.convert('RGB')

def make_rgb(x):
    return x.convert('RGB')

make_rgb._order = 0

def grandparent_splitter(fn, train_name="train", valid_name="valid"):
    folder = fn.parent.parent.as_posix().split('/')[-1]
    return True if folder == train_name else False if folder == valid_name else None

def split_by_func(items, f):
    mask = [f(o) for o in items]
    fal = [o for o, m in zip(items, mask) if m==False]
    tru = [o for o, m in zip(items, mask) if m==True]
    return tru, fal

class SplitData():
    def __init__(self, train, valid):
        self.train = train
        self.valid = valid

    def __getattr__(self, k):
        return getattr(self.train, k)

    def __setstate__(self, data:Any):
        self.__dict__.update(data)

    @classmethod
    def split_by_func(cls, il, f):
        lists = map(il.new, split_by_func(il.items, f))
        return cls(*lists)

    def __repr__(self):
        return f'{self.__class__.__name__}\nTrain: {self.train}\nValid: {self.valid}\n'


from collections import OrderedDict

def uniqueify(x, sort=False):
    res = list(OrderedDict.fromkeys(x).keys())
    if sort: res.sort()
    return res

class Processor():
    def process(self, items): return items

class CategoryProcesser(Processor):
    def __init__(self):
        self.vocab = None #this is the state, a list of unique objs

    def __call__(self, items):
        if self.vocab is None:
            self.vocab = uniqueify(items)
            self.otoi = {v:k for k,v in enumerate(self.vocab)} # obj:int from 0 to n
        return [self.proc1(o) for o in items]

    def proc1(self, item):
        return self.otoi[item]

    def deprocess(self, idxs):
        assert self.vocab is not None
        return [self.deproc1(idx) for idx in idxs]

    def deproc1(self, idx):
        return self.vocab[idx]

def parent_labeler(fn):
    return fn.parent.name

def _label_by_func(ds, f, cls=ItemList):
    return cls([f(o) for o in ds.items], path=ds.path)

class LabeledData():

    def process(self, il, proc):
        return il.new(compose(il.items, proc))

    def __init__(self, x, y, proc_x =None, proc_y=None):
        self.x = self.process(x, proc_x)
        self.y = self.process(y, proc_y)
        self.proc_x = proc_x
        self.proc_y = proc_y


    def __repr__(self):
        return f'{self.__class__.__name__}\nx: {self.x}\ny: {self.y}\n'

    def __getitem__(self, idx):
        return self.x[idx], self.y[idx]

    def __len__(self):
        return len(self.x)

    def x_obj(self, idx):
        return self.obj(self.x, idx, self.proc_x)

    def y_obj(self, idx):
        return self.obj(self.y, idx, self.proc_y)

    # method to
    def obj(self, items, idx, procs):
        isint = isinstance(idx, int) or (isinstance(idx, torch.LongTensor) and not idx.ndim)
        item = items[idx]
        for proc in reversed(listify(procs)):
            item = proc.deproc1(item) if isint else proc.deprocess(item)
        return item

    @classmethod
    def label_by_func(cls, il, f, proc_x=None, proc_y=None):
        return cls(il, _label_by_func(il,f), proc_x=proc_x, proc_y=proc_y)


def label_by_func(sd, f, proc_x=None, proc_y=None):
    train = LabeledData.label_by_func(sd, f, proc_x=proc_x, proc_y=proc_y)
    valid = LabeledData.label_by_func(sd, f, proc_x=proc_x, proc_y=proc_y)
    return SplitData(train, valid)